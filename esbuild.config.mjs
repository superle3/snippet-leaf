import esbuild from "esbuild";
import process from "process";
import path from "path";
import fs from "fs/promises";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const production = process.argv[2] === "production";
const web = process.argv[2] === "web" || process.argv.length === 2;
const codemirror = process.argv[2] === "codemirror";

const inlin_plugin = (options) => {
    const { filter, namespace, transform } = Object.assign(
        {
            /**
             *  A regex filter to match the desired import. Defaults to
             * imports that start with `inline:`, e.g. import
             * 'inline:./file.ext';
             */
            filter: /^inline:/,

            /**
             * The namespace to use. If you use more than one instance of
             * this plugin, each one should have a unique namespace. This is
             * a random string by default, so you won't need to change it
             * unless you're targeting a specific namespace.
             */
            namespace: "_" + Math.random().toString(36).substr(2, 9),

            /**
             * A function to transform the contents of the imported file.
             * This can be a simple string replace or a more complex
             * operation, such as a call to PostCSS, Sass, etc. The function
             * must return a string.
             *
             * The contents argument will be a string containing the file's
             * contents. The args argument is passed through from esbuild,
             * but the most useful is probably args.path which references
             * the file path.
             *
             * Note that heavy operations here can impact esbuild's
             * performance!
             */
            transform: async (contents, args) => contents,
        },
        options,
    );

    return {
        name: "esbuild-inline-plugin",
        setup(build) {
            let alias = Object.entries(build.initialOptions.alias ?? {});
            build.onResolve({ filter }, async (args) => {
                let inputPath = alias.reduce((path, [key, val]) => {
                    return path.replace(key, val);
                }, args.path);
                let filePath;
                if (!/^\.\.?\//.test(inputPath)) {
                    filePath = path.resolve(args.resolveDir, inputPath);
                } else {
                    filePath = inputPath;
                }
                try {
                    await fs.access(filePath);
                } catch {
                    const filtered_path = inputPath.replace(filter, "");
                    if (/^\.\.?\//.test(filtered_path)) {
                        filePath = path.resolve(args.resolveDir, filtered_path);
                    } else {
                        filePath = filtered_path;
                    }
                }

                return {
                    path: filePath,
                    namespace,
                };
            });

            build.onLoad({ filter: /.*/, namespace }, async (args) => {
                let contents = await fs.readFile(args.path, "utf8");

                if (typeof transform === "function") {
                    contents = await transform(contents, args);
                }

                return {
                    contents,
                    watchFiles: [args.path],
                    loader: "text",
                };
            });
        },
    };
};

const sharedConfig = {
    banner: {
        js: banner,
    },
    bundle: true,
    platform: "browser",
    target: ["ES2017"],
    sourcemap: production ? false : "inline",
    minify: true,
    plugins: [inlin_plugin()],
    logLevel: "info",
};

const browserConfig = {
    ...sharedConfig,
    entryPoints: [
        "browser_extension/browser_extension.ts",
        "browser_extension/settings/settings_tab.ts",
        "browser_extension/settings/content_script.ts",
    ],
    format: "iife",
    outdir: "browser_extension/dist",
    external: ["path", "fs"],
    metafile: true,
};

const codemirrorConfig = {
    ...sharedConfig,
    entryPoints: ["codemirror_extension/codemirror_extensions.ts"],
    format: "esm",
    outdir: "codemirror_extension/dist",
};
if (web) {
    const browserCtx = await esbuild.context(browserConfig);
    browserCtx.watch().catch(() => process.exit(1));
} else if (codemirror) {
    console.log("Running in development mode, watching for changes...");
    const codemirrorCtx = await esbuild.context(codemirrorConfig);
    codemirrorCtx.watch().catch(() => process.exit(1));
} else if (production) {
    console.log("Building for production...");
    await esbuild.build(browserConfig);
}
