// https://discuss.codemirror.net/t/concealing-syntax/3135

import type {
    ViewUpdate as ViewUpdateC,
    Decoration as DecorationC,
    DecorationSet as DecorationSetC,
    WidgetType as WidgetTypeC,
    ViewPlugin as ViewPluginC,
    EditorView as EditorViewC,
} from "@codemirror/view";
import type {
    EditorSelection as EditorSelectionC,
    Range as RangeC,
    RangeSet as RangeSetC,
    RangeSetBuilder as RangeSetBuilderC,
    RangeValue as RangeValueC,
} from "@codemirror/state";
import type { syntaxTree as syntaxTreeC } from "@codemirror/language";
import { conceal } from "./conceal_fns";
import type { LatexSuiteFacet } from "codemirror_extension/codemirror_extensions";
import { getLatexSuiteConfig } from "src/settings/settings";
import { debounce } from "src/utils/debounce";
// import { debounce, livePreviewState } from "obsidian";

export type Replacement = {
    start: number;
    end: number;
    text: string;
    class?: string;
    elementType?: string;
};

export type ConcealSpec = Replacement[];

export type Concealment = {
    spec: ConcealSpec;
    cursorPosType: "within" | "apart" | "edge";
    enable: boolean;
};

// Represents how a concealment should be handled
// 'delay' means reveal after a time delay.
type ConcealAction = "conceal" | "reveal" | "delay";

function ConcealWidget(WidgetType: typeof WidgetTypeC) {
    return class ConcealWidget2 extends WidgetType {
        private readonly className: string;
        private readonly elementType: string;

        constructor(
            readonly symbol: string,
            className?: string,
            elementType?: string,
        ) {
            super();

            this.className = className ? className : "";
            this.elementType = elementType ? elementType : "span";
        }

        eq(other: ConcealWidget2) {
            return (
                other.symbol == this.symbol &&
                other.className === this.className &&
                other.elementType === this.elementType
            );
        }

        toDOM() {
            const span = document.createElement(this.elementType);
            span.className = "cm-math " + this.className;
            span.textContent = this.symbol;
            return span;
        }

        ignoreEvent() {
            return false;
        }
    };
}

function TextWidget(WidgetType: typeof WidgetTypeC) {
    return class TextWidget2 extends WidgetType {
        constructor(readonly symbol: string) {
            super();
        }

        eq(other: TextWidget2) {
            return other.symbol == this.symbol;
        }

        toDOM() {
            const span = document.createElement("span");
            span.className = "cm-math";
            span.textContent = this.symbol;
            return span;
        }

        ignoreEvent() {
            return false;
        }
    };
}

/**
 * Determine if the two ConcealSpec instances before and after the update can be
 * considered identical.
 */
function atSamePosAfter(
    update: ViewUpdateC,
    oldConceal: ConcealSpec,
    newConceal: ConcealSpec,
): boolean {
    if (oldConceal.length !== newConceal.length) return false;

    for (let i = 0; i < oldConceal.length; ++i) {
        // Set associativity to ensure that insertions on either side of the
        // concealed region do not expand the region
        const oldStartUpdated = update.changes.mapPos(oldConceal[i].start, 1);
        const oldEndUpdated = update.changes.mapPos(oldConceal[i].end, -1);
        const b =
            oldStartUpdated == newConceal[i].start &&
            oldEndUpdated == newConceal[i].end;
        if (!b) return false;
    }

    return true;
}

function determineCursorPosType(
    sel: EditorSelectionC,
    concealSpec: ConcealSpec,
): Concealment["cursorPosType"] {
    // Priority: "within" > "edge" > "apart"

    let cursorPosType: Concealment["cursorPosType"] = "apart";

    for (const range of sel.ranges) {
        for (const replace of concealSpec) {
            // 'cursorPosType' is guaranteed to be "edge" or "apart" at this point
            const overlapRangeFrom = Math.max(range.from, replace.start);
            const overlapRangeTo = Math.min(range.to, replace.end);

            if (
                overlapRangeFrom === overlapRangeTo &&
                (overlapRangeFrom === replace.start ||
                    overlapRangeFrom === replace.end)
            ) {
                cursorPosType = "edge";
                continue;
            }

            if (overlapRangeFrom <= overlapRangeTo) return "within";
        }
    }

    return cursorPosType;
}

/*
 * We determine how to handle a concealment based on its 'cursorPosType' before
 * and after an update and current mousedown state.
 *
 * When the mouse is down, we enable all concealments to make selecting math
 * expressions easier.
 *
 * When the mouse is up, we follow the table below.
 * The row represents the previous 'cursorPosType' and the column represents the
 * current 'cursorPosType'. Each cell contains the action to be taken.
 *
 *        |  apart  |  edge  | within
 * -----------------------------------
 * apart  | conceal | delay  | reveal
 * edge   | conceal | delay  | reveal
 * within | conceal | reveal | reveal
 * N/A    | conceal | reveal | reveal
 *
 * 'N/A' means that the concealment do not exist before the update, which should
 * be judged by 'atSamePosAfter' function.
 */
function determineAction(
    oldCursor: Concealment["cursorPosType"] | undefined,
    newCursor: Concealment["cursorPosType"],
    mousedown: boolean,
    delayEnabled: boolean,
): ConcealAction {
    if (mousedown) return "conceal";

    if (newCursor === "apart") return "conceal";
    if (newCursor === "within") return "reveal";

    // newCursor === "edge"
    if (!delayEnabled) return "reveal";
    // delay is enabled
    if (!oldCursor || oldCursor === "within") return "reveal";
    else return "delay";
}

// Build a decoration set from the given concealments
function buildDecoSet(
    concealments: Concealment[],
    Decoration: typeof DecorationC,
    WidgetType: typeof WidgetTypeC,
) {
    const decos: RangeC<DecorationC>[] = [];
    try {
        for (const conc of concealments) {
            if (!conc.enable) continue;

            for (const replace of conc.spec) {
                if (replace.start === replace.end) {
                    // Add an additional "/" symbol, as part of concealing \\frac{}{} -> ()/()
                    decos.push(
                        Decoration.widget({
                            widget: new (TextWidget(WidgetType))(replace.text),
                            block: false,
                        }).range(replace.start, replace.end),
                    );
                } else {
                    // Improve selecting empty replacements such as "\frac" -> ""
                    // NOTE: This might not be necessary
                    const inclusiveStart = replace.text === "";
                    const inclusiveEnd = false;

                    decos.push(
                        Decoration.replace({
                            widget: new (ConcealWidget(WidgetType))(
                                replace.text,
                                replace.class,
                                replace.elementType,
                            ),
                            inclusiveStart,
                            inclusiveEnd,
                            block: false,
                        }).range(replace.start, replace.end),
                    );
                }
            }
        }

        return Decoration.set(decos, true);
    } catch (e) {
        console.log("Error building decoration set:", e);
        return Decoration.none;
    }
}

// Build atomic ranges from the given concealments.
// The resulting ranges are basically the same as the original replacements, but empty replacements
// are merged with the "next character," which can be either plain text or another replacement.
// This adjustment makes cursor movement around empty replacements more intuitive.
function buildAtomicRanges(
    concealments: Concealment[],
    RangeSetBuilder: typeof RangeSetBuilderC,
    RangeValue: typeof RangeValueC,
) {
    const repls: Replacement[] = concealments
        .filter((c) => c.enable)
        .flatMap((c) => c.spec)
        .sort((a, b) => a.start - b.start);

    // RangeSet requires RangeValue but we do not need one
    const fakeval = new (class extends RangeValue {})();
    const builder = new RangeSetBuilder();
    for (let i = 0; i < repls.length; i++) {
        if (repls[i].text === "") {
            if (i + 1 != repls.length && repls[i].end == repls[i + 1].start) {
                builder.add(repls[i].start, repls[i + 1].end, fakeval);
                i++;
            } else {
                builder.add(repls[i].start, repls[i].end + 1, fakeval);
            }
        } else {
            builder.add(repls[i].start, repls[i].end, fakeval);
        }
    }
    return builder.finish();
}

export const mkConcealPlugin = (
    revealTimeout: number,
    ViewPlugin: typeof ViewPluginC,
    EditorView: typeof EditorViewC,
    Decoration: typeof DecorationC,
    WidgetType: typeof WidgetTypeC,
    RangeSet: typeof RangeSetC,
    RangeSetBuilder: typeof RangeSetBuilderC,
    RangeValue: typeof RangeValueC,
    syntaxTree: typeof syntaxTreeC,
    latexSuiteConfig: LatexSuiteFacet,
) =>
    ViewPlugin.fromClass(
        class {
            // Stateful ViewPlugin: you should avoid one in general, but here
            // the approach based on StateField and updateListener conflicts with
            // obsidian's internal logic and causes weird rendering.
            concealments: Concealment[];
            decorations: DecorationSetC;
            atomicRanges: RangeSetC<RangeValueC>;
            delayEnabled: boolean;

            constructor() {
                this.concealments = [];
                this.decorations = Decoration.none;
                this.atomicRanges = RangeSet.empty;
                this.delayEnabled = revealTimeout > 0;
            }

            delayedReveal = debounce(
                (delayedConcealments: Concealment[], view: EditorViewC) => {
                    // Implicitly change the state
                    for (const concealment of delayedConcealments) {
                        concealment.enable = false;
                    }
                    this.decorations = buildDecoSet(
                        this.concealments,
                        Decoration,
                        WidgetType,
                    );
                    this.atomicRanges = buildAtomicRanges(
                        this.concealments,
                        RangeSetBuilder,
                        RangeValue,
                    );

                    // Invoke the update method to reflect the changes of this.decoration
                    view.dispatch();
                    //TODO: remove this when replit fixes their vim extension
                    //@ts-ignore
                    const cm = view.cm;
                    if (cm && typeof cm.signal === "function") {
                        cm.signal("vim-command-done");
                    }
                },
                revealTimeout,
                true,
            );

            update(update: ViewUpdateC) {
                const settings = getLatexSuiteConfig(
                    update.view,
                    latexSuiteConfig,
                );
                if (
                    !(
                        update.docChanged ||
                        update.viewportChanged ||
                        update.selectionSet
                    )
                )
                    return;
                if (!settings.concealEnabled) {
                    this.delayedReveal.cancel();
                    this.decorations = Decoration.none;
                    this.atomicRanges = RangeSet.empty;
                    return;
                }
                revealTimeout = settings.concealRevealTimeout;
                this.delayedReveal // Cancel the delayed revealment whenever we update the concealments
                    .cancel();

                const selection = update.state.selection;
                const mousedown: undefined = undefined;

                const concealSpecs = conceal(update.view, syntaxTree);

                // Collect concealments from the new conceal specs
                const concealments: Concealment[] = [];
                // concealments that should be revealed after a delay (i.e. 'delay' action)
                const delayedConcealments: Concealment[] = [];

                for (const spec of concealSpecs) {
                    const cursorPosType = determineCursorPosType(
                        selection,
                        spec,
                    );
                    const oldConcealment = this.concealments.find((old) =>
                        atSamePosAfter(update, old.spec, spec),
                    );

                    const concealAction = determineAction(
                        oldConcealment?.cursorPosType,
                        cursorPosType,
                        mousedown,
                        this.delayEnabled,
                    );

                    const concealment: Concealment = {
                        spec,
                        cursorPosType,
                        enable: concealAction !== "reveal",
                    };

                    if (concealAction === "delay") {
                        delayedConcealments.push(concealment);
                    }

                    concealments.push(concealment);
                }
                if (delayedConcealments.length > 0) {
                    this.delayedReveal(delayedConcealments, update.view);
                }

                this.concealments = concealments;
                this.decorations = buildDecoSet(
                    this.concealments,
                    Decoration,
                    WidgetType,
                );
                this.atomicRanges = buildAtomicRanges(
                    this.concealments,
                    RangeSetBuilder,
                    RangeValue,
                );
            }
        },
        {
            decorations: (v) => v.decorations,
            provide: (plugin) =>
                EditorView.atomicRanges.of(
                    (view) => view.plugin(plugin).atomicRanges,
                ),
        },
    );
